/*
 * Copyright 2023 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package fallback ...
package fallback

import (
	"context"
	"errors"

	"github.com/cloudwego/kitex/pkg/kerrors"
	"github.com/cloudwego/kitex/pkg/rpcinfo"
	"github.com/cloudwego/kitex/pkg/utils"
)

// ErrorFallback is to build fallback policy for error.
func ErrorFallback(ef Func) *Policy {
	return &Policy{fallbackFunc: func(ctx context.Context, req, resp interface{}, err error) (fbResp interface{}, fbErr error) {
		if err == nil {
			return resp, err
		}
		return ef(ctx, req, resp, err)
	}}
}

// TimeoutAndCBFallback is to build fallback policy for rpc timeout and circuit breaker error.
// Kitex will filter the errors, only timeout and circuit breaker can trigger the ErrorFunc to execute.
func TimeoutAndCBFallback(ef Func) *Policy {
	return &Policy{fallbackFunc: func(ctx context.Context, req, resp interface{}, err error) (fbResp interface{}, fbErr error) {
		if err == nil {
			return resp, err
		}
		if kerrors.IsTimeoutError(err) || errors.Is(err, kerrors.ErrCircuitBreak) {
			return ef(ctx, req, resp, err)
		}
		return resp, err
	}}
}

// NewFallbackPolicy is to build a fallback policy.
func NewFallbackPolicy(fb Func) *Policy {
	return &Policy{
		fallbackFunc: fb,
	}
}

// Policy is the definition for fallback.
//   - fallbackFunc is fallback func.
//   - reportAsFallback is used to decide whether to report Metric according to the Fallback result.
type Policy struct {
	fallbackFunc     Func
	realReqResp      bool
	reportAsFallback bool
}

func (p *Policy) WithRealReqResp() *Policy {
	p.realReqResp = true
	return p
}

func (p *Policy) EnableReportAsFallback() *Policy {
	p.reportAsFallback = true
	return p
}

// IsPolicyValid to check if the Fallback policy is valid.
func IsPolicyValid(p *Policy) bool {
	return p != nil && p.fallbackFunc != nil
}

// Func is the definition for fallback func, which can do fallback both for error and resp.
// Notice !! The req and resp are not the real rpc req and resp, are respectively XXArgs and XXXResult by default.
// XXArgs and XXXResult are the wrap struct for args and result and generated by Kitex.
//
//	[default] for resp, assert utils.KitexResult can get or set actual resp
//	[default] for req, assert utils.KitexArgs can get first actual req
//
// But you can configure via WithRealReqResp() to use real req and resp, then you don't need to do assert.
type Func func(ctx context.Context, req, resp interface{}, err error) (fbResp interface{}, fbErr error)

// DoFallback execute the fallback logic that user customized.
// this func is supposed not be related with Kitex.
func (p *Policy) DoFallback(ctx context.Context, req, resp interface{}, err error,
	allowReportAsFB bool,
) (fbResp interface{}, fbErr error, reportAsFallback bool) {
	if p.fallbackFunc != nil {
		fbResp, fbErr = p.fallbackFunc(ctx, req, resp, err)
		return fbResp, fbErr, p.reportAsFallback && allowReportAsFB
	}
	return resp, err, false
}

// DoIfNeeded will do prepare for fallback, which is coupled with Kitex.
func (p *Policy) DoIfNeeded(ctx context.Context, ri rpcinfo.RPCInfo, req, resp interface{}, err error) (fbResp interface{}, fbErr error, reportAsFallback bool) {
	if p == nil {
		return resp, err, false
	}
	err, allowReportAsFB := getBizErrIfExist(ri, err)
	req4FB, resp4FB := getReqAndResp(req, resp, p.realReqResp)

	fbResp, fbErr, reportAsFallback = p.DoFallback(ctx, req4FB, resp4FB, err, allowReportAsFB)

	if fbResp == nil && fbErr == nil {
		return resp, err, false
	}
	if fbErr == nil && fbResp != nil {
		fbResult := fbResp
		if !p.realReqResp {
			if kr, ok := fbResp.(utils.KitexResult); ok {
				fbResult = kr.GetResult()
				if fbResult == nil {
					return resp, err, false
				}
			}
		}
		if oriKR, ok := resp.(utils.KitexResult); ok {
			oriKR.SetSuccess(fbResult)
			fbResp = resp
		}
	}
	return
}

func getBizErrIfExist(ri rpcinfo.RPCInfo, err error) (error, bool) {
	if err == nil {
		if bizErr := ri.Invocation().BizStatusErr(); bizErr != nil {
			// biz error also as error passed to fallback
			err = bizErr
		}
		// if err is nil, reportAsFallback always be false even if user set true
		return err, false
	}
	return err, true
}

func getReqAndResp(req, resp interface{}, realReqResp bool) (req4FB, resp4FB interface{}) {
	if realReqResp {
		ka, kaOK := req.(utils.KitexArgs)
		kr, krOK := resp.(utils.KitexResult)
		if kaOK && krOK {
			return ka.GetFirstArgument(), kr.GetResult()
		}
	}
	return req, resp
}
