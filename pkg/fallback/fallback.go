/*
 * Copyright 2023 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package fallback ...
package fallback

import (
	"context"
	"errors"

	"github.com/cloudwego/kitex/pkg/kerrors"
	"github.com/cloudwego/kitex/pkg/rpcinfo"
	"github.com/cloudwego/kitex/pkg/utils"
)

// ErrorFallback is to build fallback policy for error.
func ErrorFallback(ef Func) *Policy {
	return &Policy{FallbackFunc: func(ctx context.Context, req interface{}, resp interface{}, err error) (fbResp interface{}, fbErr error) {
		if err == nil {
			return resp, err
		}
		return ef(ctx, req, resp, err)
	}}
}

// TimeoutAndCBFallback is to build fallback policy for rpc timeout and circuit breaker error.
// Kitex will filter the errors, only timeout and circuit breaker can trigger the ErrorFunc to execute.
func TimeoutAndCBFallback(ef Func) *Policy {
	return &Policy{FallbackFunc: func(ctx context.Context, req interface{}, resp interface{}, err error) (fbResp interface{}, fbErr error) {
		if err == nil {
			return resp, err
		}
		if kerrors.IsTimeoutError(err) || errors.Is(err, kerrors.ErrCircuitBreak) {
			return ef(ctx, req, resp, err)
		}
		return resp, err
	}}
}

// NewFallbackPolicy is to build a fallback policy.
func NewFallbackPolicy(fb Func) *Policy {
	return &Policy{
		FallbackFunc: fb,
	}
}

// Policy is the definition for fallback.
//   - FallbackFunc is fallback func.
//   - ReportAsFallbackRet is used to decide whether to report RPCStat according to the Fallback result.
type Policy struct {
	FallbackFunc        Func
	ReportAsFallbackRet bool
}

func (p *Policy) EnableReportAsFallbackRet() *Policy {
	p.ReportAsFallbackRet = true
	return p
}

// Func is the definition for fallback func, which can do fallback both for error and resp.
// Notice !! The req and resp are not the actual rpc req and resp, are respectively XXArgs and XXXResult
// XXArgs and XXXResult are the wrap struct for args and result and generated by Kitex
//
//	for resp, assert utils.KitexResult can get or set actual resp
//	for req, assert utils.KitexArgs can get first actual req
type Func func(ctx context.Context, req interface{}, resp interface{}, err error) (fbResp interface{}, fbErr error)

// DoFallback execute the fallback logic that user customized.
// this func is not suggested to couple with Kitex.
func (p *Policy) DoFallback(ctx context.Context, req, resp interface{}, err error,
	allowReportAsFB bool) (fbResp interface{}, fbErr error, reportAsFallbackRet bool) {
	if p.FallbackFunc != nil {
		fbResp, fbErr = p.FallbackFunc(ctx, req, resp, err)
		return fbResp, fbErr, p.ReportAsFallbackRet && allowReportAsFB
	}
	return resp, err, false
}

// DoIfNeeded will do prepare for fallback, which is coupled with Kitex.
func (p *Policy) DoIfNeeded(ctx context.Context, ri rpcinfo.RPCInfo, req, resp interface{}, err error) (fbResp interface{}, fbErr error, reportAsFallbackRet bool) {
	if p == nil {
		return resp, err, false
	}
	allowReportAsFB := true
	if err == nil {
		if bizErr := ri.Invocation().BizStatusErr(); bizErr != nil {
			// biz error also as error passed to fallback
			err = bizErr
		}
		// if err is nil, rpcStatAsFB always be false even if user set true
		allowReportAsFB = false
	}
	fbResp, fbErr, reportAsFallbackRet = p.DoFallback(ctx, req, resp, err, allowReportAsFB)
	if fbResp == nil && fbErr == nil {
		return resp, err, false
	}
	if fbErr == nil && fbResp != nil {
		// for kitex, the req/resp are XXArgs/XXXResult, the right way to set result is to call SetSuccess of origin resp
		// but for user, they may return resp directly, it won't reset the result.
		// to avoid mistaken usage, we need to do it here
		if kr, ok := fbResp.(utils.KitexResult); ok {
			fbRet := kr.GetResult()
			if fbRet == nil {
				return resp, err, false
			}
			if oriKR, ok2 := resp.(utils.KitexResult); ok2 {
				oriKR.SetSuccess(fbRet)
			}
		} else {
			// assert failed, return fallback result directly
			return fbResp, fbErr, reportAsFallbackRet
		}
	}
	return
}
